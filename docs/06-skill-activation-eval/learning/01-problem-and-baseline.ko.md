---
title: "문제점과 기준선"
description: "Claude Code Skill이 안정적으로 활성화되지 않는 이유를 이해하고 모델별 기준선 측정값을 수립합니다"
type: tutorial
tags: [AI, Testing]
order: 1
related: [./01-problem-and-baseline.en.md, ./02-hook-configurations.ko.md]
---

# Module 1: 문제점과 기준선

> Claude Code Skill은 강력하지만 신뢰할 수 없습니다 — 약 절반의 시간만 활성화됩니다

## 학습 목표

이 모듈을 완료하면 다음을 할 수 있습니다:
- Claude Code Skill이 안정적으로 자동 활성화되지 않는 이유를 설명
- **활성화(Activation)**와 **선택(Selection)**의 차이를 구분 (핵심 통찰)
- 키워드 기반 vs 의미 기반 매칭 동작을 이해
- 서로 다른 모델 간의 기준선 활성화율을 비교
- Skill 활성화가 성공하거나 실패할 가능성이 높은 상황을 식별

---

## 1.1 Skill 활성화 문제

Claude Code Skill은 도메인별 지식을 제공하도록 설계되었습니다. `.claude/settings.json`에 구성하면 Claude가 관련 시점에 `Skill()`을 호출하여 로드해야 합니다. 문제는 **항상 그렇게 하지는 않는다**는 것입니다.

### 기대하는 동작

```
사용자 프롬프트 → Claude가 Skill 평가 → Skill() 호출 → 내용 읽기 → 지식 기반 구현
```

### 실제 발생하는 동작 (약 50% 확률)

```
사용자 프롬프트 → Claude가 Skill 평가를 건너뜀 → 직접 구현 (도메인 지식 없이)
```

이것은 사소한 불편이 아닙니다. Skill에는 코딩 표준, 프레임워크 패턴, API 규칙 등 핵심 컨텍스트가 포함되어 있습니다. Claude가 이를 건너뛰면 프로젝트별 구현 대신 일반적인 코드를 생성합니다.

### 실제 영향

다음과 같은 Svelte 프로젝트 Skill이 있다고 가정합니다:
- SvelteKit 라우팅 패턴
- Runes를 사용한 상태 관리
- `$state`를 사용한 폼 처리

사용자가 "유효성 검사가 있는 연락처 폼 추가"를 요청하면 Claude는 폼 처리 Skill을 로드해야 합니다. 하지만 절반의 경우, 프로젝트의 기존 패턴 대신 일반적인 HTML 폼 코드를 작성합니다.

---

## 1.2 활성화 vs 선택: 핵심 통찰

연구를 통해 중요한 구분이 드러났습니다:

| 개념 | 정의 | Claude의 성능 |
|------|------|--------------|
| **활성화(Activation)** | Claude가 `Skill()`을 호출하는지 여부 | ~50% (문제) |
| **선택(Selection)** | 활성화 시 어떤 Skill을 선택하는지 | ~100% (문제 아님) |

**이것은 솔루션 접근 방식을 완전히 바꿉니다.** Claude에게는 "잘못된 Skill" 문제가 없습니다. "Skill 단계를 건너뛰는" 문제가 있을 뿐입니다. Skill 시스템을 사용할 때는 항상 올바른 Skill을 선택합니다.

### 이것이 중요한 이유

문제가 선택(잘못된 Skill 선택)이었다면 더 나은 Skill 설명, 개선된 매칭 알고리즘, 의미 검색이 필요했을 것입니다. 하지만 문제가 활성화(시스템 자체 사용)이므로 해결책은 더 간단합니다: **Claude가 행동하기 전에 Skill을 평가하도록 강제하는 것**입니다.

문서가 어디에 있는지 알지만 찾아보지 않는 개발자와 비슷합니다 — 해결책은 더 나은 문서가 아니라 문서를 먼저 확인하도록 하는 프로세스입니다.

---

## 1.3 키워드 매칭 vs 의미 이해

Claude의 Skill 활성화는 의미 이해가 아닌 **키워드 매칭**을 사용합니다. 이는 Skill 설명과 프롬프트 작성 방법에 직접적인 영향을 미칩니다.

### 작동하는 경우: 직접 키워드 트리거

| 프롬프트 | Skill 설명에 포함된 내용 | 활성화? |
|---------|----------------------|--------|
| "`$state`를 사용하여 폼 추가" | "`$state` 관리" | ✅ 예 |
| "SvelteKit 라우팅 구현" | "SvelteKit 라우팅" | ✅ 예 |
| "반응성을 위해 runes 사용" | "Svelte runes" | ✅ 예 |

### 실패하는 경우: 의미적/개념적 트리거

| 프롬프트 | Skill 설명에 포함된 내용 | 활성화? |
|---------|----------------------|--------|
| "폼 액션 추가" | "폼 처리 패턴" | ❌ 아니오 |
| "페이지를 반응형으로 만들기" | "Svelte runes, `$state`" | ❌ 아니오 |
| "사용자 입력 처리" | "폼 유효성 검사, `$state`" | ❌ 아니오 |

### 패턴

```
프롬프트와 Skill 설명 간 키워드 겹침    → 활성화 가능성 높음
키워드 겹침 없는 의미적 관계           → 활성화 가능성 낮음
```

기준선 활성화율이 약 50%인 이유가 설명됩니다: Skill 키워드를 재사용하는 직관적인 프롬프트는 작동하지만, 키워드 겹침이 없는 개념적으로 관련된 프롬프트는 활성화를 트리거하지 않습니다.

### 실질적 함의

Hook 없이 활성화를 개선하려면:
1. 많은 키워드 변형이 포함된 Skill 설명 작성
2. 사용자에게 특정 용어 사용 안내
3. 하지만 어느 접근법도 100%에 도달하지 못함 — Hook이 필요한 이유

---

## 1.4 모델 차이: Sonnet vs Haiku

모든 모델이 Skill 활성화를 동일하게 처리하지는 않습니다:

| 모델 | 기준선 활성화율 | 참고 |
|------|--------------|------|
| **Sonnet 4.5** | ~50-55% | 사용 가능하지만 불안정 |
| **Haiku 4.5** | ~0% | 사실상 Skill 사용 불가 |

### Haiku가 실패하는 이유

Haiku는 처리량에 최적화된 더 작고 빠른 모델입니다. 다음을 수행할 충분한 용량이 부족한 것으로 보입니다:
1. Skill 시스템 지침 파싱
2. Skill 관련성 평가
3. `Skill()`을 도구로 호출하기로 결정

이것은 구성 문제가 아닙니다 — Haiku는 단순히 Skill 메커니즘과 상호작용하지 않습니다. Skill 활성화가 필요하다면 **Sonnet이 최소 요구 모델**입니다.

### Sonnet의 불일관성

Sonnet의 약 55%도 문제가 됩니다. 불일관성은 다음을 의미합니다:
- 같은 프롬프트, 같은 Skill → 실행마다 다른 동작
- Skill 활성화 여부를 예측할 방법 없음
- 중요한 워크플로에 Skill을 의존할 수 없음

이 변동성이 활성화를 보장하는 Hook 기반 솔루션 탐색의 동기가 되었습니다.

---

## 1.5 기준선 수립

기준선 측정은 다음 조건에서 수행되었습니다:

| 매개변수 | 값 |
|---------|-----|
| 모델 | Sonnet 4.5 (`claude -p` 사용) |
| Skill | Svelte 관련 3개 |
| 프롬프트 | 표준 12개 + 엣지 케이스 4개 |
| 구성당 실행 횟수 | 3회 이상 |
| 환경 | Daytona 샌드박스 |

### 표준 프롬프트 (키워드 풍부)

Skill 설명의 키워드를 자연스럽게 포함하는 프롬프트:

```
"add a contact form with validation using $state"
"implement SvelteKit routing for the dashboard"
"create a reactive counter component using runes"
```

**기준선 결과: 50-55% 활성화율**

### 엣지 케이스 프롬프트 (의미만)

키워드 겹침 없이 동일한 작업을 설명하는 프롬프트:

```
"add form actions to handle user submissions"
"make the page respond to user interactions"
"build a component that tracks a changing value"
```

**기준선 결과: 더 낮은 활성화율** — 키워드 의존성 확인.

### 데이터에서 "활성화"의 의미

각 호출은 JSONL 출력을 생성합니다. 활성화는 도구 이름이 `Skill`인 `tool_use` 이벤트를 검색하여 감지합니다:

```json
{"type":"content_block_start","content_block":{"type":"tool_use","name":"Skill","input":{"skill_name":"svelte-form-handling"}}}
```

이러한 이벤트가 없으면 = 해당 실행에서 Skill이 활성화되지 않음.

---

## 핵심 요약

- Claude Code Skill은 Sonnet 4.5에서 약 50-55%만 활성화됨 (Haiku: ~0%)
- **활성화 ≠ 선택**: Claude는 활성화 시 항상 올바른 Skill을 선택 — 문제는 아예 활성화하지 않는 것
- 활성화는 의미 기반이 아닌 **키워드 기반**: 프롬프트가 Skill 설명과 용어를 공유해야 함
- 기준선 변동성은 개입 없이는 중요한 워크플로에 Skill을 의존할 수 없음을 의미
- 해결 공간은 선택 개선이 아닌 활성화 강제(Hook)

## 연습문제

### 연습문제 1.1: 활성화 트리거 식별

다음 Skill 설명이 있을 때:
```
"Svelte 5 runes patterns: $state, $derived, $effect for reactive state management"
```

어떤 프롬프트가 활성화될 가능성이 높을까요?
1. "카운터에 반응형 상태 추가"
2. "`$state`를 폼 필드에 사용"
3. "데이터가 변경될 때 컴포넌트 업데이트"
4. "`$derived`를 계산된 값에 구현"
5. "대시보드에서 사이드 이펙트 처리"

### 연습문제 1.2: 모델 동작 예측

팀이 Next.js 프로젝트에 5개의 커스텀 Skill을 사용합니다. Hook 없이 Sonnet 4.5에서 동일한 프롬프트를 10번 실행합니다.

- Skill이 몇 번이나 활성화될 것으로 예상하나요? (범위 제시)
- Haiku로 전환하면 신뢰성이 향상될까요? 이유는?
- Hook 없이 활성화율을 가장 크게 개선할 수 있는 한 가지 변경은?

### 연습문제 1.3: 문제 분류

각 시나리오에 대해 활성화 문제인지 선택 문제인지 식별하세요:
1. Claude가 Svelte Skill을 로드하지 않고 React 컴포넌트를 작성
2. Claude가 폼 처리 요청 시 라우팅 Skill을 로드
3. Claude가 프로젝트 규칙 대신 일반 패턴으로 기능 구현
4. Claude가 올바른 Skill을 로드하지만 지침을 잘못 해석

---

## 다음 단계

[Module 2: Hook 구성](./02-hook-configurations.ko.md)으로 계속하여 다양한 Hook 메커니즘이 활성화 문제를 어떻게 해결하는지 알아보세요.
