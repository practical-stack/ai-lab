---
title: "모듈 3: 결정 프레임워크"
description: "기능 요청의 핵심 타입(Skill/Agent)과 Command 래퍼 필요성을 결정하는 2단계 결정 트리와 체크리스트 실용 가이드"
type: tutorial
tags: [AI, Architecture, BestPractice]
order: 3
depends_on: [./02-relationships.ko.md]
related: [./03-decision-framework.md]
---

# 모듈 3: 결정 프레임워크

> 핵심 타입(Skill/Agent) 결정 + Command 래퍼 판단 - 실용 가이드

## 학습 목표

이 모듈을 완료하면:
- 모든 기능 요청을 분류하는 결정 트리를 적용할 수 있습니다
- 체크리스트를 사용하여 컴포넌트 선택을 검증할 수 있습니다
- 다양한 접근법 간의 트레이드오프를 이해합니다

---

## 3.1 핵심 결정 트리 (2단계)

### 1단계: 핵심 타입 결정

```
                    ┌─────────────────────────┐
                    │     새 기능 요청        │
                    └───────────┬─────────────┘
                                │
                                ▼
                ┌───────────────────────────────────┐
                │ 동적 분기를 포함한 다단계         │
                │ 계획이 필요한가?                  │
                └───────────┬───────────────────────┘
                            │
              ┌─────────────┴─────────────┐
              │                           │
              ▼ 예                        ▼ 아니오
      ┌───────────────┐        ┌────────────────────────┐
      │  🤖 AGENT     │        │ 관련 상황에서 에이전트  │
      │               │        │ 가 자동 로드해야 하는   │
      │ 다단계 추론   │        │ 도메인 지식인가?       │
      │ 필요          │        └───────────┬────────────┘
      └───────┬───────┘                    │
              │              ┌─────────────┴─────────────┐
              │              │                           │
              │              ▼ 예                        ▼ 아니오
              │      ┌───────────────┐          ┌───────────────┐
              │      │  📚 SKILL     │          │ 기존 컴포넌트 │
              │      │               │          │ 에 내장       │
              │      │ 자동 로드     │          └───────────────┘
              │      │ 지식          │
              │      └───────┬───────┘
              │              │
              ▼              ▼
```

### 2단계: Command 래퍼 필요 여부

```
      ┌─────────────────────────────────┐
      │ Skill 또는 Agent 결정 후:       │
      │                                 │
      │ 다음 중 해당되는 것이 있나?     │
      │ • allowed-tools 제한 필요?      │
      │ • 위험한/되돌릴 수 없는 작업?   │
      │ • 구조화된 $ARGUMENTS 검증?     │
      │ • / 메뉴 단축키 필요?          │
      └───────────┬─────────────────────┘
                  │
    ┌─────────────┴─────────────┐
    │                           │
    ▼ 예                        ▼ 아니오
┌───────────────┐       ┌───────────────────┐
│ ⚡ COMMAND     │       │ Skill/Agent를     │
│ 래퍼 추가     │       │ 직접 사용         │
│               │       │ (@path 또는       │
│ Skill/Agent   │       │  목표 할당)       │
│ 위의 UI+보안  │       └───────────────────┘
└───────────────┘
```

---

## 3.2 결정 질문 상세 설명

### 질문 1: 다단계 계획이 필요한가?

**스스로 물어보세요:**
- 결과에 따라 여러 번의 반복이 필요한가?
- 중간 발견에 따라 접근법이 바뀌는가?
- 분기 로직이 있는가 (X면 Y 수행, 아니면 Z 수행)?
- 예상치 못한 상황에 적응해야 하는가?

| 시나리오 | 답변 | 결과 |
|----------|------|------|
| "이 버그를 분석하고 해결책 테스트해서 수정해줘" | 예 | Agent |
| "이 설정으로 프로덕션에 배포해줘" | 아니오 | Q2로 이동 |
| "언어 선택에 따라 프로젝트 구조 생성해줘" | 아마도 | 복잡도에 따라 다름 |

### 질문 2: 워크플로우 간 재사용 가능한가?

**스스로 물어보세요:**
- 다른 에이전트/커맨드에서 이 기능이 필요할까?
- 이것은 도메인 지식인가, 특정 액션인가?
- 중복하면 유지보수 문제가 생길까?

| 시나리오 | 답변 | 결과 |
|----------|------|------|
| "TypeScript 코딩 가이드라인" | 예 | Q3으로 이동 |
| "이 특정 앱 배포" | 아니오 | Q4로 이동 |
| "코드 리뷰 프랙티스" | 예 | Q3으로 이동 |

### 질문 3: 에이전트가 자동 로드해야 하는가?

**스스로 물어보세요:**
- 관련 상황에서 에이전트가 "그냥 알아야" 하는가?
- 컨텍스트 의존적인 전문 지식인가?
- 명시적 호출이 필요하면 성가실까?

| 시나리오 | 답변 | 결과 |
|----------|------|------|
| "React 코드 작성 시 React 베스트 프랙티스" | 예 | **Skill** |
| "복잡한 배포 절차" | 아니오 | **Command** |
| "로그 추가 시 로깅 표준" | 예 | **Skill** |

### 질문 4: 플랫폼 제약조건이 필요한가? (Command 래퍼 판단)

핵심 타입(Skill/Agent) 결정 후, Command 래퍼 필요 여부를 판단합니다.

**스스로 물어보세요:**
- `allowed-tools` 제한이 필요한가? (도구 샌드박싱)
- 위험한/되돌릴 수 없는 작업인가? (명시적 사용자 트리거 필요)
- 구조화된 `$ARGUMENTS` 검증이 필요한가?
- `/` 메뉴 단축키가 필요한가? (발견 가능성)

| 시나리오 | 래퍼 필요? | 결과 |
|----------|-----------|------|
| "프로덕션에 배포" (위험한 작업) | 예 | Agent + **Command 래퍼** |
| "API 문서 생성" (안전한 작업) | 아니오 | Skill/Agent 직접 사용 |
| "저장 시 코드 포맷" (자동 동작) | 아니오 | Skill 직접 사용 |
| "git 도구만 허용하는 작업" | 예 (`allowed-tools`) | Skill + **Command 래퍼** |

---

## 3.3 설계 선택 체크리스트

각 기능에 대해 이 체크리스트를 통과하세요:

### 체크리스트 질문

| # | 질문 | 예 → |
|---|------|------|
| 1 | **재사용성이 높은가?** | Skill 쪽으로 기울임 |
| 2 | **외부 부작용/위험이 있는가?** | 확인 포함 Command 필요 |
| 3 | **사용자가 직접 트리거해야 하는가?** | 반드시 Command |
| 4 | **결정적 안정성이 필요한가?** | Skill/Command에 명시 (Agent 자유 추론 아님) |
| 5 | **다단계 계획/분기가 필요한가?** | Agent 필요 |
| 6 | **보안/권한 경계가 있는가?** | 별도 Agent 또는 Command로 분리 |
| 7 | **실행 비용이 높은가?** | 명시적 승인 포함 Command |

### 체크리스트 적용

**예: "PR 생성 시 보안 이슈 자동 리뷰"**

| 질문 | 답변 | 함의 |
|------|------|------|
| 재사용성 높은가? | 예 | Skill일 수 있음 |
| 부작용? | 예 (댓글 작성) | 확인 필요 |
| 사용자 트리거? | 아니오 (PR 자동) | Command 아님 |
| 결정적? | 아니오 (코드마다 다름) | Agent 추론 필요 |
| 다단계? | 예 (스캔, 분석, 보고) | Agent |
| 보안 경계? | 예 (저장소 접근) | 범위 제한 권한 |
| 높은 비용? | 중간 | 제한과 함께 OK |

**결과: Agent** with `security-review` skill 로드, PR 이벤트에 의해 트리거, 댓글 작성은 확인 필요.

---

## 3.4 빠른 결정 치트 시트

### 1단계: 핵심 타입 결정

#### TOOL 사용 시:
- 작업이 원자적이고 결정적
- 단일 API 호출 또는 명령
- 추론 불필요 - 순수 실행

#### SKILL 사용 시 (핵심 타입):
- 도메인 전문 지식 필요
- 관련 시 에이전트가 자동 로드해야 함 (또는 `@path`로 직접 호출)
- 실행이 아닌 지식
- 워크플로우 간 재사용 가능

#### AGENT 사용 시 (핵심 타입):
- 동적 도구 선택 필요
- 다단계 추론 필요
- 예상치 못한 상황에 적응해야 함
- 피드백 루프 필요

#### 새 컴포넌트를 만들지 않을 때:
- 기존 agent/skill에 추가 가능
- 일회성 작업
- 오버헤드가 이점보다 큼

### 2단계: Command 래퍼 추가 시

#### COMMAND 래퍼를 추가하는 경우:
- `allowed-tools` 제한이 필요 (도구 샌드박싱)
- 위험한/되돌릴 수 없는 작업 (명시적 사용자 트리거)
- 구조화된 `$ARGUMENTS` 검증 필요
- `/` 메뉴 단축키로 발견 가능성 필요

#### COMMAND 래퍼가 불필요한 경우:
- Skill이 `@path`로 직접 호출 가능
- Agent가 목표 할당만으로 충분
- 도구 제한 없이 단순히 Skill을 감싸기만 하는 경우

---

## 3.5 자주 혼동되는 경계 사례 (Q&A)

### Q1: "Command가 여러 Skill을 호출할 수 있나요?"

**A: 네!** Command는 절차의 일부로 여러 Skill을 로드할 수 있습니다.

```markdown
# /release Command
1. "testing" skill 로드 → 릴리스 전 체크 실행
2. "deployment" skill 로드 → 프로덕션에 배포
3. "notification" skill 로드 → 알림 전송
```

### Q2: "Skill에 LLM 프롬프트가 있으면 Agent인가요?"

**A: 아닙니다.** Skill은 지시사항이고, Agent는 실행 엔티티입니다.
- Skill: "보안 이슈 분석하는 방법은 이것입니다"
- Agent: "이 skill을 사용해서 보안 이슈를 분석하겠습니다"

### Q3: "여러 Agent가 하나의 Skill을 공유할 수 있나요?"

**A: 네!** Skill은 공유되도록 설계되었습니다.
- `logging` skill → dev agent, test agent, deploy agent 모두 사용
- 각 agent는 자신의 권한/역할 범위 내에서만 사용

### Q4: "유사한 Command - 통합할까 분리할까?"

**A: 보통 통합** 하고 매개변수로 구분합니다.

| 나쁨 | 좋음 |
|------|------|
| `/build-api`, `/build-ui`, `/build-worker` | `/build [api\|ui\|worker]` |
| `/deploy-dev`, `/deploy-prod` | `/deploy [dev\|prod]` |

### Q5: "항상 적용되는 규칙 - Skill인가 다른 것인가?"

**A: Skill 아닙니다.** 영구 규칙을 사용하세요.

| 유형 | 위치 |
|------|------|
| 항상 켜진 규칙 | `CLAUDE.md`, `.cursorrules`, 시스템 프롬프트 |
| 상황적 지식 | Skill (관련 시 로드) |

---

## 3.6 결정 트리 연습

### 연습 시나리오 1

**기능:** "문서가 없는 함수에 자동으로 JSDoc 주석 추가"

결정 트리를 따라가 보세요:

<details>
<summary>정답</summary>

1. **동적 분기를 포함한 다단계 계획?** → 아마도 (각 함수 분석 필요)
2. **재사용 가능?** → 예 (모든 JS/TS 코드에 적용)
3. **관련 시 자동 로드?** → 예 (JS/TS 파일 편집 시)

**결과: Skill** 이름은 `jsdoc-generator`

하지만 잠깐 - 실제로 파일을 수정해야 한다면, Agent가 skill을 사용해서 주석 추가 방법을 가이드받고, 도구를 사용해서 실제로 추가합니다.

최종 답: **Skill** (지식/패턴용) + Agent가 사용
</details>

### 연습 시나리오 2

**기능:** "30일 이상 된 모든 테스트 픽스처 삭제"

<details>
<summary>정답</summary>

1. **다단계 계획?** → 아니오 (결정적: 오래된 파일 찾기, 삭제)
2. **재사용 가능?** → 아마도 (재사용될 수 있음)
3. **사용자 트리거 필요?** → 예 (파괴적 작업!)

**결과: Command** `/cleanup-fixtures`

- 명시적 사용자 트리거 필요
- 확인 단계 포함해야 함
- `--dry-run` 옵션 포함 가능
</details>

### 연습 시나리오 3

**기능:** "개발자가 회사의 마이크로서비스 아키텍처 패턴을 따르도록 도움"

<details>
<summary>정답</summary>

1. **다단계 계획?** → 아니오 (계획이 아닌 지식)
2. **재사용 가능?** → 예 (모든 마이크로서비스 작업에 적용)
3. **관련 시 자동 로드?** → 예 (서비스 아키텍처 작업 시)

**결과: Skill** 이름은 `microservices-architecture`

포함 내용:
- 서비스 설계 패턴
- 통신 패턴 (REST, gRPC, 이벤트)
- 데이터 소유권 원칙
- 예제 폴더 구조
</details>

### 연습 시나리오 4

**기능:** "버그 리포트 분석, 재현, 근본 원인 찾기, 수정 생성"

<details>
<summary>정답</summary>

1. **다단계 계획?** → 예 (분석 → 재현 → 조사 → 수정)
2. **동적 분기?** → 예 (다른 버그는 다른 접근법 필요)
3. **발견에 따라 적응?** → 예 (조사가 다음 단계 결정)

**결과: Agent** 이름은 `bug-fix-agent`

사용 skills: `debugging`, `testing`, `coding-guidelines`
사용 tools: `file_read`, `test_runner`, `code_search`, `file_edit`
</details>

---

## 3.7 결정 매트릭스 요약

### 핵심 타입 (Knowledge Layer)

| 기능 유형 | 컴포넌트 | 핵심 지표 |
|-----------|----------|-----------|
| 도메인 전문 지식 | Skill | "X에 대한 지식" |
| 자동화된 추론 작업 | Agent | "X 방법을 알아내서 해결" |
| 재사용 가능한 절차 | Skill workflow | "X 하는 단계" |
| 단일 작업 | Tool | "그냥 X 수행" |
| 항상 적용 규칙 | Rules 파일 | "항상 X 따르기" |

### Command 래퍼 (Access Layer)

| 조건 | Command 래퍼 필요 | 예시 |
|------|-------------------|------|
| `allowed-tools` 제한 | ✅ | `/deploy` (git, npm만 허용) |
| 위험한 작업 | ✅ | `/cleanup-fixtures` (파일 삭제) |
| `$ARGUMENTS` 검증 | ✅ | `/build [component]` |
| `/` 단축키 | ✅ | `/review-pr` (자주 사용) |
| 위의 어느 것도 해당 없음 | ❌ | Skill/Agent 직접 사용 |

---

## 핵심 정리

1. **결정 트리로 시작** - 순서대로 질문 따르기
2. **체크리스트 사용** - 특정 기준으로 선택 검증
3. **의심스러우면 단순하게 시작** - 나중에 언제든 승격 가능
4. **컴포넌트 조합** - 대부분의 기능은 여러 컴포넌트 유형 사용
5. **과도한 엔지니어링 피하기** - 모든 것에 새 컴포넌트가 필요하지 않음

---

## 다음 모듈

[모듈 4: 실용적 설계 템플릿](./04-templates.ko.md) - Command, Skill, Agent를 위한 스펙 문서 작성법을 배웁니다.
