---
title: "개념 정의 및 경계"
description: "Command, Skill, Agent의 정확한 정의와 분리 방법, 프레임워크별 용어 매핑 및 경계 케이스 Q&A."
type: explanation
tags: [Architecture, AI]
order: 1
related: "./01-concepts.en.md"
---

# AI Agent 아키텍처: Command, Skill, Agent 설계 가이드

## A. 개념 정의 & 경계 (정확한 분리)

### 용어 정합성 배경

"Command", "Skill", "Agent"라는 용어는 AI 에이전트 생태계마다 약간씩 다르게 쓰입니다.

| 프레임워크                       | 용어 사용                                            |
| -------------------------------- | ---------------------------------------------------- |
| OpenAI LangChain / 자율 에이전트 | "툴(Tool)"과 "액션(Action)" 중심, "Skill" 용어 드묾  |
| Cursor / Claude Code / OpenCode  | Commands, Skills, Agents 명확히 구분                 |
| Microsoft Semantic Kernel        | 함수 모음을 "Skill"이라 부르지만 "Command" 개념 없음 |

**Claude Code/OpenCode 기반 환경**에서는 Command/Skill/Agent가 공식적으로 정의되어 있으므로, 이 표준에 따라 개념을 구분합니다.

---

### Command (명령)

> **"무엇을 할지"** 에 대한 정확한 지시

**정의:**

- 주로 사람이 슬래시("/") 명령 형태로 직접 트리거
- 에이전트에게 특정 작업 수행을 결정적으로 요구
- 고정된 프롬프트 또는 절차를 담은 마크다운 스크립트
- 프로젝트 전역 또는 로컬에 저장
- 파일 이름이 슬래시 명령 이름이 됨 (예: `commands/deploy.md` → `/deploy`)

**입력/출력:**

- **Input:** 필요시 파라미터를 받아 프롬프트에 삽입 (예: `/release 1.2.3`)
- **Output:** 에이전트가 Command 내용을 실행한 결과로 산출하는 응답 또는 코드 변경

**상태/부작용:**

- 실행 시점에만 컨텍스트를 소비 (평소에는 부담 없음)
- 실행 시 실제 툴 호출이나 코드 변경 등의 부작용 발생 가능

**실패:**

- 툴 오류나 조건 불충족 시 즉시 오류 보고 또는 재시도
- 원인: 잘못된 인수, 툴 실패, 프롬프트 한계 등

**경계:**

- 사용자 또는 상위 에이전트가 **명시적으로 호출**하는 경우에만 동작
- 에이전트가 자동으로 Command를 선택하지 않음
- Skills처럼 조건부 로드되지 않음

---

### Skill (기술)

> **"어떻게 할지"** 에 대한 재사용 가능한 지식/절차

**정의:**

- 특정 도메인 또는 작업 영역의 전문 지식과 단계를 묶은 모듈
- 에이전트가 상황에 따라 알아서 로드하거나 사용자가 필요시 호출
- 폴더 단위(도메인 컨테이너)로 관리
- `SKILL.md` 메타데이터와 하위 워크플로우 파일들로 구성

**입력/출력:**

- **Input:** 트리거 조건(키워드, 상황)이 정의되어 있어 relevant 시 자동 로드
- **Output:** 독자적인 최종 출력 없음 → 에이전트 대화 컨텍스트에 주입되어 행동/응답 변화

**상태/부작용:**

- 주로 프롬프트 수준의 지식
- 필요시 스크립트나 리소스 파일(CLI 스크립트 등) 포함 가능
- Skill 자체는 상태를 가지지 않고 불러올 때마다 동일하게 동작

**실패:**

- 로딩 실패는 드묾 (키워드 매칭 안 되면 애초 로드 안 됨)
- Skill 내 절차 오류 시 에이전트가 해당 지시 수행 중 실패 가능

**경계:**

- 항상 에이전트의 맥락 속에서 동작
- **스스로 추론하거나 계획하지 않음**
- LLM이 Skill 사용 여부와 순서를 결정
- Command와 달리 **자동으로 Relevant 시 로드**되는 것이 핵심
- "에이전트가 아는 지식/절차"로 이해

---

### Agent (에이전트)

> **"누가 일을 수행하는가"** 에 해당

**정의:**

- 지능적인 작업 조정자
- LLM 인스턴스(혹은 프로세스)에 특정 역할과 목표를 부여한 것
- "작업자 프로필(worker profile)"이라고도 함

**주요 기능:**

- 사용자 입력이나 상위 명령(목표)을 받아 계획(Workflow/Plan) 수립
- 필요한 Skill을 선택 및 로드
- 적절한 툴(함수, CLI) 호출해 작업 수행
- 복잡한 문제 해결을 위해 여러 단계 추론
- 필요시 병렬로 **Sub-agent(하위 에이전트)** 생성해 작업 분담

**입력/출력:**

- **Input:** 사람의 프롬프트나 상위 시스템의 지시 → **목적(Goal)**으로 설정
- **Output:** 최종 결과(설명, 코드, 요약 등) 산출 또는 다른 agent/시스템에 전달

**상태:**

- 대화 내역, 진행 상황 등의 메모리/컨텍스트 유지
- 자체적인 시스템 프롬프트(역할 지침)과 도구 접근 권한 스코프 보유
- 필요시 독립된 컨텍스트 창 사용 (메인 에이전트 컨텍스트 오염 방지)

**부작용:**

- 툴을 통해 외부 세계에 영향을 미치는 모든 행위 실행
- 코드 수정, 웹 데이터 수집, CI 파이프라인 실행 등
- **권한 관리 및 제한이 중요한 계층**

**실패:**

- 목적 달성 불가, 무한 루프, 컨텍스트 초과, 툴 실패 누적 등
- 자체 휴리스틱으로 재시도하거나 중간 결과와 실패 원인 보고 후 종료

**경계:**

- 스스로 새로운 지식을 만들어내지 않음
- 주어진 모델과 Skill/Tool 내에서 작동
- 각 Agent는 **별도 시스템 프롬프트와 권한**을 가진 독립 실행 단위
- 하나의 Agent가 또 다른 Agent를 생성 가능 (격리된 컨텍스트에서 동작)
- Skill과의 차이: Skill은 정적 지식, **계획/추론 주체는 Agent**

**대안 용어 매핑 표:** 주요 프레임워크별로 위 개념과 유사한 용어를 정리하면:

#### Command (Cursor/Claude Code)

| 타 환경 용어 | 설명 |
|-------------|------|
| Workflow / Slash Command | Claude Code 문서에서 "Workflow"는 과거 "Command"와 동일 |
| Function / Tool Action | OpenAI 함수호출에서 미리 정의된 함수 호출 |
| Intent Trigger | 대화형 봇에서 사용자가 호출하는 특정 명령 |

#### Skill (Agent Skill 표준)

| 타 환경 용어 | 설명 |
|-------------|------|
| Skill | 동일 (IBM Watson Assistant 등에서 모듈화된 대화 스킬) |
| Knowledge Pack / Rule | Cursor 초기버전에서 Rules를 Skill처럼 사용 |
| Prompt Template / Chain | LangChain에서 특정 작업용으로 짜여진 체인 또는 프롬프트 세트 |

#### Agent (Claude/Cursor)

| 타 환경 용어 | 설명 |
|-------------|------|
| Sub-agent | Claude에서 사용자 정의 에이전트 |
| AI Worker / Bot | 일반적인 자율 에이전트 |
| Planner / Orchestrator | Semantic Kernel의 Plan은 Agent 유사 |
| Assistant Instance | OpenAI API에서 프롬프트에 따라 동작하는 어시스턴트 |

#### Tool (함수/API/CLI)

| 타 환경 용어 | 설명 |
|-------------|------|
| Tool | 동일 (LangChain 등) |
| MCP Function | Claude의 Model-Context-Protocol 툴 |
| Function (API) | OpenAI 함수 |
| Action | ReAct 프레임워크에서 LLM이 취하는 행동 |

> **요약:** Command는 환경에 따라 "Workflow"나 "Slash 명령"으로 불리며, Skill은 다른 맥락에서 "Rule"이나 단순 프롬프트 템플릿과 유사하게 취급될 수 있습니다. Agent는 흔히 "자율 에이전트" 혹은 "Subagent" (하위 에이전트) 등의 용어로도 불립니다.

---

## 서로 혼동하기 쉬운 경계 사례 (10가지) – Q/A 형태 테스트

아래는 Command, Skill, Agent의 경계를 혼동하기 쉬운 사례 10가지를 질의응답으로 정리했습니다.

### 1. Q: "커맨드(명령) 내부에서 여러 스킬을 순차로 호출해도 되나요?"

**A:** 가능합니다.

- Command는 본질적으로 하나의 지정된 워크플로우를 실행하는 스크립트
- 그 절차 안에 여러 Skill을 로드하거나 여러 단계를 포함할 수 있음
- 예: `/release` 커맨드가 "release 스킬 로드 → 체크리스트 수행 → notification 스킬 로드 → 알림 전송"
- Command의 역할: 여러 작업을 단일 트리거로 묶어 편리하게 실행

**주의사항:**
- Command 자체는 정해진 순서를 따를 뿐 추론하지 않음
- 각 단계의 실행 성공 여부는 에이전트가 모니터링
- 실패 시 다음 단계 중단 또는 롤백 처리

### 2. Q: "Skill이 LLM 프롬프트와 툴 호출까지 다 포함하면, 혼자 판단도 하니 에이전트랑 다를 게 없지 않나요?"

**A:** 다릅니다.

**Skill의 특성:**
- 사전 정의된 지침 세트일 뿐 **스스로 판단(loop)**하지 않음
- "코드 변경 후 테스트 실행" 같은 절차가 쓰여 있어도, 실행 주체는 Agent
- 툴 호출 포함 시에도 Agent에게 "이렇게 써라"라고 알려주는 것
- Skill 파일 자체에 실행 엔진이 내장된 것이 아님

**Agent의 특성:**
- Skill 내용을 읽고 따라하며 순서 제어
- 도중에 분기나 추가 판단 필요 시 Agent가 수행
- 새로운 상황에 대해 자체 추론과 의사결정

> **비유:** Skill = "스크립트", Agent = "스크립트를 해석·실행하고 필요하면 응용"

### 3. Q: "에이전트가 자동으로 어떤 Command를 사용할 수도 있나요?"

**A:** 예, 특정 구현에서는 가능합니다.

**가능한 경우:**
- Cursor 등 일부 프레임워크에서는 에이전트가 상황에 따라 Command 자율 실행 가능
- "multi-step workflow" 요구 시, 등록된 Command를 발견하면 툴처럼 호출

**일반 원칙:**
- Command는 원칙적으로 사람의 명시적 지시를 위한 것
- Claude Code에서는 Command가 "Workflow"로 개념 재편
- 에이전트는 주로 Skill 기반으로 자율 행동
- Command는 수동 트리거가 원칙, 자동 의사결정에는 Skill/Tool 활용

**설계 권장사항:**
- 에이전트가 Command를 자동 호출하게 하려면
- → 그 Command 내용을 Skill로 승격시키거나 Agent logic에 통합하는 편이 더 명확

### 4. Q: "사람이 직접 호출하지 않아도 항상 적용돼야 하는 지식이라면 Skill 대신 뭐가 좋을까요?"

**A:** **Rule(규칙)**을 사용하는 것이 적합합니다.

**Skill의 한계:**
- "코딩 스타일 가이드"처럼 모든 요청에 항상 적용되어야 하는 지침
- Skill로 만들면 관련 키워드에만 반응하므로 누락될 수 있음

**Rule 적용 방법:**
- 시스템 프롬프트의 항상적 규칙으로 설정
- Cursor의 `.cursor/rules/`에 상시 적용 규칙으로 추가

**정리:**
- 전역 불변 규칙 → Agent의 기본 지식이나 별도 Rule
- Skill → **"필요할 때 추가되는 모듈"**로 한정

### 5. Q: "Command와 Skill 둘 다 재사용 가능한데, 언제 Skill로 만들고 언제 Command로 만들까요?"

**A:** 사용 방식과 역할에 따라 결정합니다.

| 구분 | Skill | Command |
|------|-------|---------|
| **사용 시점** | 에이전트가 필요를 스스로 인지해서 로드 | 사용자가 그 시점을 지정하여 실행 |
| **용도** | 다른 Skill이나 Agent에서도 참조 가능한 모듈 | UI 단의 단축키처럼 조합된 작업 호출 |
| **내용** | 논리나 정책을 담음 | 조합된 작업 실행 |

**선택 기준:**
- "이 기능을 에이전트가 언제 쓸지 스스로 판단하게 둘까?" → **Skill**
- "매번 내가 명령해서 쓰게 할까?" → **Command**

### 6. Q: "여러 Agent가 있는데, 하나의 Skill을 함께 써도 되나요?"

**A:** 예, Skill은 범용 모듈이므로 여러 에이전트가 공유 가능합니다.

**공유 가능성:**
- 예: Logging Skill → 개발자용 에이전트, 테스트용 에이전트 모두 사용 가능
- Claude나 Cursor 환경에서는 Skill이 개방형 표준
- 여러 플랫폼 간에도 호환 가능하게 설계됨

**주의사항:**
- 각 Agent는 자신의 권한/역할 범위 내에서만 Skill 활용
- 특정 툴(예: 배포 권한) 필요 시, 해당 툴 접근권한이 있는 Agent에서만 정상 작동
- 동시성 문제는 보통 없으나, Skill이 같은 리소스(예: 임시 파일)를 수정하는 설계는 피할 것

### 7. Q: "한 에이전트 내부에서 모든 걸 다 처리하게 만들면 Skill이나 Sub-agent가 꼭 필요할까요?"

**A:** 권장되지 않습니다. 모든 지침을 하나의 Agent에 집어넣는 것은 안티패턴입니다.

**문제점:**
- 처음에는 간단해 보여도 Agent 프롬프트가 비대해짐
- 중복이 생겨 관리 어려움과 혼동 발생
- Claude도 "에이전트는 간결하고 특화될수록 좋다"고 평가

**Skill/Sub-agent의 장점:**

| 방법 | 효과 |
|------|------|
| Skill로 지식 분리 | 여러 Agent간 중복 제거, 컨텍스트 절약 |
| Sub-agent로 역할 분리 | 병렬처리 가능, 컨텍스트 관리 유리 |

**권장사항:**
- 공통 로직 → Skill로 모듈화
- 독립 작업 → Sub-agent로 분리

### 8. Q: "Skill이 너무 많아지면 오히려 에이전트가 뭘 써야 할지 혼란스럽지 않을까요?"

**A:** Skill 폭발은 관리로 해결 가능합니다.

**시스템적 해결:**
- Skill이 수십 개 넘어서면 Claude 등은 Skill 디스커버리 통해 관련된 몇 개만 로드
- 잘 설계된 환경에서는 Agent가 프롬프트 분석 → 가장 어울리는 Skill 선택
  - 키워드 매칭
  - vector search
- Skill 수가 많아져도 성능상 큰 문제 없음

**관리자 역할:**
- 각 Skill에 "언제 써야 하는지" 명확한 설명 기술
- 중복되는 Skill 정리
- 도메인별로 Skill 카테고리화
- 사용 빈도 낮은 것 주기적으로 아카이빙 또는 통합

**예시:**
- "데이터베이스\_\*" 스킬 5개 → 하나의 "Database" Skill에 워크플로우 5개로 묶기
- Agent 혼란 감소 + 유지보수 용이

### 9. Q: "Command를 남발하면 안 좋나요? 예: build-api, build-ui 따로 커맨드 2개 vs build 스킬 하나."

**A:** 과도한 커맨드 분리는 피하십시오.

**문제점:**
- Command 개수가 너무 많으면 사용자가 기억하거나 찾기 어려움
- Skill 기반 자동화와 충돌 가능성

**권장 해결책:**
- 비슷한 작업을 하는 여러 Command → 하나의 Skill + 하나의 Command로 통합
- 예: `/build-api`, `/build-ui` (절차 유사) → 공통 Build 스킬 + `/build api` 파라미터로 분기

**원칙:**
- Command 목록은 적고 기억하기 쉽게, 안정적으로 유지
- 세부 로직은 Skill에 위임
- 커맨드 = UI/UX 편의 수단 (로직 보관 수단 아님)
- 같은 종류의 작업은 하나의 Command로 일원화

### 10. Q: "Skill에 담긴 절차가 매번 반드시 실행돼야 한다면, 굳이 Skill로 둘 필요 없이 그냥 Command로 만드는 게 낫나요?"

**A:** 그렇습니다.

**Skill의 특성:**
- 에이전트가 **"필요시 사용"**하는 옵션
- 특정 시나리오에서 항상 쓰이는 절차라면 Skill로 분리하는 이점 적음

**권장 설계:**
- 매번 실행되어야 하는 절차 → Command나 Agent 본연의 워크플로우에 직접 포함
- 예: "사용자 로그인 후 audit 로그 남김"
  - Skill로 분리 시 → 에이전트가 놓칠 위험
  - → Agent의 기본 시나리오에 포함 또는 Command 시퀀스의 한 단계로 명시

**Skill로 분리하는 경우:**
- 여러 시나리오에서 간헐적으로 재사용될 때
- 분리해 관리할 가치가 있을 때로 한정
