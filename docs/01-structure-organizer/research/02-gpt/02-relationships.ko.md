---
title: "관계 모델"
description: "계층적 구성 모델, I/O 및 예외 처리의 계약 정의, 버전 관리와 테스트 롤백의 운영 패턴."
type: explanation
tags: [Architecture, AI]
order: 2
related: ["./02-relationships.en.md"]
depends_on: [./README.md]
---

# B. 관계 모델 (연관 구조)

## 1. 계층 구조 (Hierarchy)

시스템 구성은 계층적으로, 상위 계층이 하위를 오케스트레이션하는 형태를 취합니다.

```
Agent (최상위)
  └── Workflow/Plan (계획)
        └── Command / Skill
              └── Tool (API, CLI, 함수)
```

### Agent 계층

- 사용자 의도를 받아 목표 설정
- 고유한 컨텍스트/역할로 추론 및 계획 수행
- 필요시 여러 Sub-agent를 병렬 생성하여 작업 병렬화
- 어떤 Skill과 Command를 사용할지 결정
- 툴 접근 관리

### Command/Workflow 계층

- Agent가 수행해야 할 구체 절차를 실행
- Claude Code에서 "Workflow"는 Commands와 유사한 의미
- Skill 및 Tool 호출 순서를 기술한 미니 스크립트
- Command가 없으면 Agent가 자체 Plan에 따라 Skill/Tool을 직접 호출

### Skill 계층

- Agent가 특정 도메인 작업 필요시 대응하는 Skill 로드
- 한 번에 여러 Skill 함께 로드 가능 (예: tanstack + panda-css)
- 추가 지식, 체크리스트, 템플릿 등을 Agent에게 제공
- Agent는 Skill이 제시한 워크플로우대로 Tool 호출

### Tool 계층

- 실제 프로그래밍 함수, 외부 API, CLI 명령, DB 쿼리 등 실행
- 예: 파일 검색 툴, gh CLI 실행
- 실행 결과(JSON, 명령 출력 등)는 다시 Agent에게 반환

---

**계층 분리의 장점: 관심사의 분리**

| 계층 | 역할 |
|------|------|
| Agent | "무엇을 할지" (플랜/의사결정) |
| Skill | "어떻게 할지" (검증된 절차 제공) |
| Tool | 실제 실행 |

**예시:** Agent가 "이 코드를 리팩토링하자" 결정 → Skill이 tanstack 사용법 제공 → Tool이 파일쓰기 실행

**구조가 깨지는 경우:**
- Agent에 상세 절차까지 하드코딩 → Skill 계층 이점 상실
- Skill이 무분별하게 툴을 직접 실행 → Agent 통제 없이 부작용 발생

---

## 2. 계약 (Contract) – 계층 간 I/O 및 예외 정책

각 계층은 인터페이스(입출력)와 실패 처리 규약을 명확히 가져야 합니다.

### Agent Contract

Agent는 **사용자로부터 목표/요청(Input)**을 받고 **해결책(Output)**을 반환합니다.

**입력 형태:**
- 자유 자연어
- 상위 시스템이 준 구조화된 명세(JSON)

**출력 형태:**
- 사용자에게 보여줄 답변
- 생성된 코드
- 보고서 등

**실패 시 처리:**

| 상황 | 처리 방식 |
|------|-----------|
| 타임아웃 | 지정된 시간/스텝 내에 완료 못 하면 `ERROR_TIMEOUT` 형태로 알림 |
| 툴 오류 | 일정 횟수(예: 3회)까지 자체 재시도, 불가 시 사용자에게 추가 정보 질문 |
| 필수 필드 누락 | 즉시 오류 반환 (예: `{"error": "missing field X"}`) |

**Skill/Tool 상호작용 계약:**
- Skill 로드 시 description 필드만 먼저 읽어 컨텍스트에 최소한만 추가
- 실제 본문은 필요할 때 Lazy-load (토큰 최적화)
- Tool 호출은 함수 시그니처에 맞게 JSON 인자를 넣고, 반환값 JSON을 파싱
- Tool이 예외/오류를 throw하면 `failure_reason` 등의 표준 필드로 처리

> **요약:** Agent 계약 = "이런 입력이 오면 내부적으로 Skill/Tool을 활용하여 이런 형태의 출력을 돌려준다. 실패 상황에서는 표준 에러 응답을 준다. 진행 중 적정 횟수와 시간 이내에 완료 못 하면 중지하고 보고한다."

---

### Command Contract

Command는 파라미터화된 프롬프트 템플릿으로서, 정해진 인자와 결과 형태를 가집니다.

**입력 계약:**
- 예: `/deploy <env>` 커맨드는 `<env>` 인자로 `dev`/`prod`만 허용
- 잘못된 값 입력 시 `ERROR: invalid environment` 출력
- `${1}`, `${2}` 같은 위치 매개변수를 통해 입력 소비
- Agent는 사용자가 준 인자를 해당 위치에 삽입해 프롬프트 완성

**출력 계약:**
- Command 자체는 최종응답이 아닌 절차
- 완료되면 Agent가 작업 결과를 요약해주거나 산출물 제공
- 예: `/code-review` 실행 후 "코드 리뷰를 완료했습니다" + 발견된 이슈 목록

**실패 처리:**
- 내부 툴 실패 시: `<툴이름> FAILED: <reason>` 형식으로 보고
- idempotent 설계: 같은 파라미터로 두 번 실행해도 시스템 무결성 유지
- dry-run 모드 지원 (예: `/deploy --dry-run`)
- 타임아웃 정책 명시 (예: 배포 5분 내 미완료 시 `ERROR: Deployment timed out`)

> **핵심:** Command는 입력 인자 → 프롬프트/Skill → 툴 → 출력의 플로우를 갖는 작은 프로그램으로 취급하여 Input/Output/Failure 조건을 명세해야 함

---

### Skill Contract

Skill은 Agent에 제공되는 모듈식 기능이므로, **트리거**와 **내용**의 계약이 핵심입니다.

**트리거 계약:**
- Skill의 메타데이터(YAML frontmatter)에 `name`, `description`, `USE WHEN` 키워드 정의
- "프롬프트에 X 키워드나 상황이면 이 Skill을 로드한다" 명시
- "이 Skill은 이런 상황에는 쓰지 않는다" 명시
- 예: Logging Skill의 description에 `USE WHEN: code logging, debug` / `DO NOT USE WHEN: database transaction`

**내용 계약:**
- Skill 본문에 지시사항의 형식과 의도 기술
- 예: "이 Skill이 로드되면, Agent는 반드시 3단계 체크리스트를 수행한다"
- Tool(script) 동반 시 해당 툴의 입력/출력 계약도 포함
- "성공 기준" 섹션 제공 시 Agent는 해당 기준으로 작업 완료 여부 판단

**오류/예외 처리:**
- Skill 자체 로드 실패는 드묾
- Skill 내 오류(예: 오타)가 Agent 수행 중 오류 유발 가능
- Agent는 Skill명을 밝히며 오류 보고 (예: `ERROR in Skill 'X': ...`)
- 또는 Skill 없이 플랜 B 시도

**시간/리소스 정책:**
- 자동 로드 시 최대 병렬 로드 개수 제한
- 한 번에 컨텍스트에 넣는 토큰 수 제한
- Anthropic Claude: description만 우선 참고, 필요한 Skill만 풀 삽입 (토큰 최적화)

> **왜 중요한가?** Skill은 여러 사람이 작성하고 Agent가 자동선택하므로, 명확한 계약이 없으면 잘못된 Skill이 불려 엉뚱한 행동을 할 수 있음

---

### Tool Contract

Tool은 대부분 함수 시그니처나 CLI 인터페이스로 정의됩니다.

**정의 방식:**
- 함수형 툴: JSON Schema로 인자 타입/필수여부/반환 구조 명세
- CLI 툴: 명령어 옵션과 출력 포맷 정의
- Agent(혹은 Skill)는 이 스키마를 준수하여 호출

**오류 처리:**
- API 호출: HTTP 상태코드나 에러메시지 반환
- CLI: 종료코드나 stderr
- Agent는 `exit code != 0`이면 실패로 인지
- 사용자에게 `TOOL_FAILED` 같은 표준 에러 전달

**시간 제한:**
- 각 툴 호출은 개별 타임아웃/재시도 정책 보유
- 예: 웹 검색 툴은 30초 후 타임아웃

**보안:**
- 툴은 Agent 권한 범위 내에서만 작동
- 예: "파일삭제 툴"은 prod 디렉토리 접근 불가

**데이터 계약:**
- 반환 데이터의 단위와 의미 문서화
- 예: Embedding 툴은 항상 1536차원 벡터를 float32로 반환

> **핵심:** Tool 계층 계약은 외부 시스템과 Agent 간의 API 계약이므로, 일반 소프트웨어 API 설계와 동일한 엄밀함이 요구됨

요약하면, 각 계층은 상하위와 주고받는 입력/출력 형태, 에러 처리, 시간/자원 한계 등을 명확히 정의해야 합니다. 이를 지키면 시스템이 예측가능하고 견고해집니다. 만약 계약을 어길 경우 (예: Skill이 예상보다 큰 텍스트를 내보내 컨텍스트를 초과), 상위 계층에서 이를 통제하거나 잘라내는 식으로 디폴트 안전장치를 마련해 두는 것도 필요합니다.

---

## 3. 운영 (Ops) – 버전 관리, 테스트, 모니터링, 롤백

AI 에이전트 시스템도 소프트웨어와 마찬가지로 운영/유지보수 원칙이 필요합니다.

### 버전닝 (Versioning)

Commands, Skills, Agents 각각에 버전 식별을 부여하는 것이 좋습니다.

**버전 관리 방법:**
- Skill 폴더에 CHANGELOG 두기
- Skill YAML frontmatter에 `version: 1.2` 필드 추가
- 스킬/커맨드 변경 시 팀원에게 공지
- 버전 충돌 시 구버전 파일 유지 여부 결정
- 플러그인 형태 배포 시 (예: Claude Plugins) 버전별 릴리즈 관리

**하위호환성:**
- 새로운 Skill/Command는 이전 버전과 동일한 인터페이스 유지
- 큰 변경은 새 이름이나 major 버전으로 분리
- Agent의 프롬프트 구조나 사용 방법 변경 시 `Agent v2` 식으로 명시

**운영 전략:**
- 프로덕션 환경에는 안정 버전만 배포
- 실험적 변경은 별도 브랜치/폴더 (예: `.assistant_dev/`)에서 시험 후 머지
- 버전 관리는 문서화하고 팀원 합의하에 적용

---

### 테스트 (Testing)

에이전트 구성요소는 단위 테스트 + 통합 테스트 전략을 가져갑니다.

**유닛 테스트:**
- Command와 Skill은 입력 프롬프트에 대한 예상 출력을 검증
- 예: `/add-user John` Command 실행 → "User John created" 포함 확인
- Skill 유닛 테스트: Skill 로드 시 Agent 행동 변화 시뮬레이션
- 예: Skill의 체크리스트 항목이 실제로 이행되는지 log 확인

**통합 테스트:**
- 전체 에이전트 워크플로우를 시나리오별로 검사
- 예: "버그 → 수정 → PR생성" 에이전트 테스트
  - 가상 코드베이스와 버그 제공
  - Agent가 PR까지 만드는지 관찰
- Mock Tool 사용 (예: Git 툴 모킹하여 push 없이 응답만 흉내냄)
- 성능 측정

**시뮬레이션:**
- 중요한 워크플로우는 dry-run으로 정기 시뮬레이션
- 예: 배포 에이전트는 staging 환경에서 주기적 실행
- LLM 응답의 비결정성 고려 → 테스트 여러 번 반복하여 신뢰도 향상
- 모든 테스트는 CI에 통합 → 새 Skill/Command 추가 시 자동 검증
- hallucination이나 정책 위반 조기 발견 (Anthropic eval 등 활용)

---

### 관측 (Observability)

운영중인 에이전트 시스템은 로그, 추적, 메트릭 수집으로 투명하게 모니터링되어야 합니다.

**로그:**
- Agent가 실행한 모든 Command, Skill 로드, Tool 호출을 시간순 기록
- 각 로그 항목엔 trace ID나 세션 ID 첨부
- 특정 사용자 요청 → 하위 에이전트 → 커맨드 → 툴 호출까지 연결된 흐름 추적
- 예: `trace abcd-1234`로 "사용자 요청 수신 → Agent Plan 수립 → Skill X 로드 → Tool Y 호출 → 완료" 전체 로깅

**메트릭:**
- 주요 성능 지표 수집:
  - 평균 토큰 사용량
  - 응답 시간
  - 성공률
  - 재시도 횟수
  - 오류 유형 빈도
- 계층별 통계: "어떤 Skill이 몇 번 호출됐는지", "특정 Command 실패율은?"
- 대시보드로 시각화 → 이상 징후(예: 실패율 급등) 빠르게 감지

**트레이싱:**
- OpenTelemetry 같은 분산 트레이싱 개념 도입
- Agent 내 의사결정 경로 재구성
- 주요 단계에 태그를 달아 자동 추적
- 외부 API 호출 시 응답시간 등 추적 → 병목 파악

**알림:**
- 오류나 중요한 이벤트 발생 시 팀 채널로 알림
- 예: "배포 에이전트 3회 연속 실패 - 확인 필요"
- 관측을 철저히 해 두면 근본원인 분석과 개선 속도 향상

---

### 롤백 (Rollback)

잘못된 Skill/Command/Agent 업데이트로 문제가 생길 경우, 신속히 이전 안정 상태로 돌아갈 수 있어야 합니다.

**버전 롤백:**
- Git 등 형상관리를 활용하여 이전 버전 태그
- 문제 발생 시 해당 버전으로 revert
- 런치 다크리 방식: 새 버전을 특정 사용자나 퍼센트만 적용
- Agent 이중화: 새 버전 오류 시 즉시 세션 종료 → 이전 Agent 인스턴스로 재시도

**상태 롤백:**
- 에이전트 실행 도중 부작용 발생 시 (예: 파일 생성, 권한 변경)
- 사전에 정해둔 정리 절차로 원상복구
- 예: "새 프로젝트 생성" 에이전트 중간 실패 → 만든 파일들 삭제하는 롤백 커맨드 실행
- 외부 시스템 영향 시 (배포, 결제 등) 트랜잭션적 대응 필요

**사용자 안내:**
- 롤백 발생 시 "X작업이 실패하여 이전 상태로 복구했습니다" 알림
- 롤백 상황 자체도 로그에 남기고 원인 분석
- 다음 패치에 반영

---

### 요약: 왜 이런 구조가 좋은가?

| 관점 | 장점 | 깨지는 경우 |
|------|------|-------------|
| **계층 구조** | 모듈화와 역할분리를 통해 복잡성 관리, 재사용성 극대화 | 경계가 모호해지면 (예: 모든 걸 하나에 집어넣음) |
| **계약** | 명확한 인터페이스 정의로 예측 가능, 디버깅 용이 | 암묵적 가정에 의존해 구현 시 (예: 문서화 없이 Skill 작성) 호환성 문제 발생 |
| **운영** | 철저한 버전/테스트/모니터링으로 신뢰성 담보 | 운영절차 없이 변경을 일방적으로 하면 장애와 혼란 발생 |
